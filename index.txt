1. Testing이란 ?
- 제품이 예상하는 대로 동작하는지 확인.
(함수, 특정한 기능, UI, 성능 API 스펙)

2. 테스트를 하는 시기
- 기존에는 개발이 완료된 후 QA팀에서 기능을 하나 하나 사용하며 테스트를 진행하였음 => 개발보다 QA가 더 오래걸리는 병목현상 발생
- 현재 테스트를 자동화하고 개발하면서 QA도 동시에 진행되도록 변화함 => 속도가 빨라지고 많은 양의 테스트 코드를 쉽게 작성할 수 있어짐

3. 테스트 장점
- 제품/기능에 대한 자신감이 생김
- 기능이 정상 동작하는지 확인
- 요구 사항 만족
- 이슈에 대해 예측할 수 있음
- 버그를 빠르게 발견할 수 있음
- 자신감 있게 리팩토링할 수 있음
- 손쉬운 유지 보수
- 코드의 품질 향상
- 코드간 의존성을 낮춤
- 좋은 문서화
- 개발 시간을 절약할 수 있음

4. 테스트 피라미드
     / E2E Test(end to end) \   : UI 테스트, 사용자 테스트
    /    Intergration Test   \  : 통합 테스트 (모듈들, 클래스들)
   /         Unit Test        \ : 단위 테스트 (함수, 모듈, 클래스)
   => 피라미드 상위로 올라갈수록, 비용이 비싸고 속도가 느리기 때문에 단위 테스트 단계에서 최대한 많이 테스트를 수행하는 것이 효율적임

5. TDD
: Test-driven development 테스트 주도 개발 방식
개발하기 전 테스트 코드를 먼저 작성하는 것.
- 장점 : 모든 요구사항에 대해 점검 가능. 
         사용자 입장에서 코드를 작성. 코드 퀄리티 향상
         시스템 전반적인 설계 향상
         개발 집중력 향상
- 언제 해야하는지 ? TDD를 사용하는 것은 개인(팀)의 자유이지만, 레포지토리에 머지하기 전에 코드와 테스트를 함께 포함해야함
- 언제 사용하면 좋은지 : 요구사항이 명확할 떄
                         비즈니스 로직
                         협업시 명세서 역할
                         설계에 대한 고민이 필요

6. CI/CD
[Continuous Intergration] 지속적인 통함
(1). 코드 변경사항을 주기적으로 빈번하게 머지해야 한다.
(2). 통합을 위한 단계 (빌드, 테스트, 머지)의 자동화
- 장점 : 코드의 퀄리디 향상
         버그 수정 용이
         개발 생산성 향상
         문제점을 빠르게 발견
[Continuous Deployment] 지속적인 배포

------------------------------------------------------------------------------------------

# 테스팅의 원칙
1. 테스트 코드의 비밀
  - 한번 작성된 테스트 코드는 영원히 유지보수 해야 함
  - 내부 구현 사항을 테스트하면 안됨 (사용자의 입장에서만 고려)
  - 재사용성을 높이기 (테스트 유틸리티)
  - 배포용 코드와 철저히 분리
  - 테스트코드를 통한 문서화

2. 테스트 코드의 구조
  - before [beforeEach, beforeAll]
  - a Test 
    [
      준비 arrange given,  > 준비 과정을 재사용
      실행 act when,       > 의도적으로 실패하기
      검증 assert then     > 가장 마지막에
    ]
  - after [afterEach, afterAll]

3. 좋은 테스트의 원칙 
* FIRSR
  - F(Fast): 느린것에 대한 의존성 낮추기 => 파일, 데이터베이스, 네트워크를 mock/stub 으로 대체
  - I(Isolated): 최소한의 유닉으로 검증하기 => 독립적이고, 집중적으로 유지 <어디서 실패했는지 알아보기 쉽도록>
  - R(Repeatable): 실행할 때마다 동일한 결과를 유지 => 환경에 영향을 받지 않도록 작성 <다른 테스트코드에 의존하거나 또는 불안정한 외부적 환경(네트워크)에 의존하는 코드는 결과값이 달라질 수 있음> 
  - S(Self-Validating): 스스로 결과를 검증하기 => 자동화를 통한 검증단계(CI/CD)
  - T(Timely): 시기적절하게 테스트 코드 작성 => 사용자에게 배포되기 이전에 테스트 코드를 작성

  4. 무엇을 테스트 해야 할지 모를때의 원칙
  * Right-BICEP
    : 모든 요구사항이 정상 동작 하는지 확인 <모든 결과가 정확한지 확인>
  - B(Boundary conditions) : 모든 코너 케이스에 대해 테스트를 하기 
    => 잘못된 포맷의 인풋, null, 특수 문자, 잘못된 이메일, 작은 숫자, 큰 숫자, 중복, 순서가 맞지 않음
  - I(Inverse relationship) : 역관계를 적용해서 결과값을 확인
    => 일관성을 유지(덧셈 -> 뺄셈, 추가 -> 제거)
  - C(Cross-check) : 다른 수단을 이용해서 결과값이 맞는지 확인
    => 추가된 과일 == 전체 과일 - 예전의 과일 갯수
        A 알고리즘 == B 알고리즘
  - E(Error conditions) : 불행한 경로에 대해 우아하게 처리하는지
    => 네트워크 에러, 메모리 부족, 데이터베이스 중지
  - P(Performance characteristics) : 성능 확인은 테스트를 통해 정확한 수치로 확인
    => 성능 개선의 척도와 확인도 데이터를 통해 확인

# 테스트의 조건
5. 좋은 테스트의 커버리지
* CORRECT
- C(Conformance) : 특정 포맷을 준수
  => 전화번호, 이메일, 아이디, 파일 확장자...
- O(Ordering) : 순서 조건 확인하기
  => 순서가 중요한 경우
- R(Range) : 숫자의 범위
  => 제한된 범위보다 작거나 큰 경우
- R(Reference) : 외부 의존성 유무, 특정한 조건의 유무
  => ~일떄, ~가 되어 있을떄, 어떤 특정한 상황/상태일때 이런 동작을 한다
- E(Existence) : 값이 존재 하지 않을때 어떻게 동작하는지
  => null, undefined, "", 0
- C(Cardinality) : 0-1-N 법칙에 따라 검증
  => 하나도 없을때, 하나만 있을때, 여러개가 있을떄
- T(Time) : 상대, 절대, 동시의 일들
  => 순서가 맞지 않은 경우, 소비한 시간, 지역 시간